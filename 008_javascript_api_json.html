<!doctype html>
<html>
 <head>
  <title>Downloading data from other websites using Javascript</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  </head>
 <body>
  <h1>Downloading data from the web using Javascript</h1>
  
Websites basically present data to their users. Most of the websites we interact with have data 
geared towards a human being: HTML to categorize information, and CSS to make its presentation
nice for a human viewer.

There are websites that inted to make their data easy to access, not only to humans, but also to
computers. The main difference between humans and computers is that computers are not as good
as humans to search for a given piece of information if it is in the middle of more data. For
example, it is reasonably easy for a human to look at a photo and try to see if there is
something in that photo (for example, a fruit on top of a book); a computer has a much harder
time doing that. As a result, when website data is targeted towards being used by a computer,
or by a program running in a computer, its data tends to be made available in a format that
makes it easy for the computer to make sense of it. There are many ways to do this; a popular
way to do this is by using a language called JSON. 

JSON is short for Javascript Object Notation, and it was designed to make it easy for Javascript
programs to deal with website data. In theory, a Javascript program can download a HTML page in the
same way as a human would, but HTML is a format designed to structure data for humans; JSON attempts
to structure data for computers.

The rules to make information easy to access for a computer are usually  
called an API (short for application program interface); the ones to interact with humans are
usually called GUI (short for graphical user interface). Thus, the 
rules to access information via JSON are called a JSON API.

Most JSON files are used to represent sequences of attributes with values (foe example, weight and 40kg), 
which often represents
objects from the real world. As a result, these collections of attributes with values are called JSON objects.
A JSON attribute together with its value is also called a JSON property. For example, we can represent a given orange fruit
with a JSON object, with an attribute called <b>weight</b> whose value is <b>100g</b>, and an attribute 
called <b>color</b> which can be <b>orange</b>, an attribute called <b>bittenByABug</b> whose
value may be <b>some people say yes, some people say no</b>, and an attribute called
<b>numberOfBugsLivingInside</b> whose value is <b>35</b>. We are free to put any number of
attributes in an object, and to give any value that we wish to those attributes, and to write them
in any order we wish. The JSON way to represent this orange object would be:
<pre>
 {
   "weight": "100g",
   "color": "orange",
   "bitenByBug": "some people say yes, some people say no",
   "numberOfBugsLivingInside": 35
 }
</pre>
The presence of blank spaces is irrelevant outside of the inside of quotes (where by blank spaces we
  mean the space bar ones, and any tabs, and newlines); the spaces between quotes are relevant
  because they have meaning (for example, <b>red car</b> is different from <b>redcar</b>). For example, 
  the above example file is for practical purposes the same as the following one:
<pre>
{"weight":"100g","color":"orange","bitenByBug":"some people say yes, some people say no","numberOfBugsLivingInside":35}
</pre>
When presenting JSON files for human reading, those spaces are often used to make it prettier. When transferring them
between computers, the semantically meaningless spaces are usually eliminated.

JSON bbjects are represented betweeen brackets, with their properties separated by commas, and where
each property has an attribute name written between quotes, and an attribute value that either
is an integer name (which may be written without quotes), or a piece of information of any kind (which
must be written inside quotes), or a boolean valuie that may be <b>true</b> or <b>false</b> (without quotes),
or the value <b>null</b> (without quotes), which means that that specific property has an empty value (whatever
that means is up to interpretation according to the rules used by the website that creates the JSON object).

JSON files can also have collections of objects. These collection of objects are called arrays,
and are written between square brackets; order inside an array matters. For example, if we have a box with three objects: an apple, an strawberry,
and a beach ball, we can represent those contents as:
<pre>
[
 {"weight": "80g", "isFruit": "yes", "fruitType": "apple", "color": "green", "isItMine": "yes"},
 {"weight": "20g", "isFruit": "yes", "fruitType": "strawberry", "isItMine": "maybe", "willIEatItSoon": "hopefully so"},
 {"weight": "400g", "isFruit": "no", "description": "beach ball", "isItMine": "no", "color": "blue", "texture": "plastic"},
]
</pre>
  
Many websites offer data in JSON format. Websites like these are intended to be used by browsers running Javascript programs;
  these programs typically download the JSON data and represent it in the browser in some way that is nice for
  the users of that webiste, or of other websites. For example, let' consider
  a hypothetical news website <em>castillanews.com</em>, which offers pieces of information in JSON, which include things 
  like headines and brief descripions of news items; this means that, when connecting to <b>https://castillanews.com/</b>,
  users (both humans observing it, or web browsers downloading it with Javascript), see something like this:
  <pre>
  [
  { "headline": "New province discovered!", "description": "Earthquake creates new province near the Padornelo", "date": "01/01/2024 13:00GMT"},
  { "headline": "UFOs in Burgos", "description": "UFOs land in Burgos due to lack of fuel; they stay until Monday", "date": "01/01/2024 13:10GMT"},
  { "headline": "Sky is blue", "description": "Researchers have confirmed that the sky is blue; other opinions exist", "date": "01/01/2024 13:12GMT"}
  ]
  </pre>
  Then, the programmers creating another website, for example <em>https://universenews.com</em>, can use a Javascript program
  in their website that connects to castillanews.com each minute, downloads the JSON information like the example above, and show the
  headlines and dates in their top of the page; they may also download at the same time other JSDN files from other news websites,
  and combine all that information; the possibilities here are endless, as decided by the programmer creating the webpage.
  
  In another example, imagine that the website <em>https://trackacar.com</em> offers services to track a vehicle as as function of 
  its license plate, in such a way that if a user wants to know the last coordinates of the car whose license plate is ES123456ABC,
  the need to write in the browser <em>https://trackacar.com?licenseplate=ES123456ABC</em> (so, a closing interrogation sign is
  written after the website name, and the data is written in a format like: property equals value), and the website returns a JSON object
  like this:
  <pre>
  {"position": "45.23478N, 5.234W", "dateandtime": "15/03/2023 18:23:44GMT"}
  </pre>
  which are the coordinates of the last known position of the vehicle. Then, the designer of a website called <em>https://showmyfriendscars.com</em>
  that has a list of license plates of the vehicles of its 10 best friends, can use Javascript to download periodically (e.g., each minute) the position
  of all its friends' cars, and, using a map of the world as the background photo of the website, plot a big yellow circle on each of the 
  points of the coordinates of the cars, so it creates a easy way to visually track where are those cars.
  
  Many websites that offer JSON data often ask for payment, others are free; in many cases, you need to register in the website itself before
  being able to access the JSON data. A typical way to register is by entering an email and then receiving in the emnail 
  what is called an API key, which is essentially a password that allows to access the services of the website. For example, 
  imagine that the license plate tracker website asks for registration before giving the information (with or witout payment) and 
  sends to our email the API key <em>wq345rfds9dh</em> (API keys tend to look like random data, and they tend to be longer than in this example); each
  registered user will receive a different API key that will allow the website owner to keep track of how often each user
  uses the service; websites that ask for payment often charge monthly a credit card number provided by the user when regiatering the email, 
  and the amount depends on how many times the API key has been used to connect to the servide.
  The website will tell us how to use that API key to access the information. One common way is to append it to the URL that is used to
  access the browser like
  <pre>
  https://trackacar.com?licenseplate=ES123456ABC&apikey=wq345rfds9dh
  </pre>
 The above way to write needed pieces of information (in this example, license plate and api key) is called URL parameters. The name of the
  website is written normally <em>https://trackacar.com</em>, and the start of the needed parameters are indicated by the interrogation sign <b>?</b>,
  and then the parameters themselves are written separated by an ampersand <b>&</b> and each parameter is written with an equal sign <b>=</b>
  separating the name of the parameter from its value. The ownwer of the website will tell us which names we need to use , and the format
  that we need to use for its values. For example, a hypothetical website tellig us the weather forecast for a given city for a given day
  could be in any of the following formats:
  <pre>
  https://www.favoriteweatherforecaster.com?city=burgos&country=spain&date=25/12/2034
  https://www.favoriteweatherforecaster.com?city=burgos&country=spain&date=25/12/2034&apikey=213rfcvwvcewfg
  https://www.favoriteweatherforecaster.com?coordinates=42.35N3.7W&date=25/12/2034&apikey=213rfcvwvcewfg
  </pre>
  
  Sometimes, instead of URL parameters, or in addition to URL parameters, the webiste where we are
  registering will tell us that we need to use a HTTP header with some information: for example, that
  the API key needs to be sent in a HTTP request header named <b>myapikey</b>, and whose value
  must be the APIkey that we received in the email. We will see below how to do this using Javascript.
  
  <br>
  
  You can search in Google for something like "free public APIs" to find many websites that offer APIs to
  access data through the Internet (usually in JSON format), in areas like weather, transportation, literature,
  games, jobs, shopping, tracking, art, etc.
  
  In order to grab data from a website with Javascript, we need to use a piece of data called an object.
  In Javascript, an object is a collection of data properties, also called fields, that often represents an object from the
  physical world. An object can be created in several ways, but a common one is to write something like
  this: <b>let micoche = {};</b>. This tells the browser that there is a variable that we chose to call
  <em>micoche</em> that will be a container of several properties with values, that we will create later
  in the code. For example, we can write at some point something like <b>micoche.marca = "Volkswagen";</b>
  and that would add a property that we chose to call <b>marca</b>, with a value that we chose to call <b>Volkswagen</b>.
  We also can later do things like <b>micoche.numeroDePuertas = 5;</b> to indicate that we use a number, in this case 5,
  as the value for a property that we chose to call <em>numeroDePuertas</em>. 
  
  In order to download data from a website, either with JSON content or nor, we use a type of object called
  a XMLHttpRequest. It is a type of object that is created by the browser and contains properties that allow
  to take care of all the complexities involved in downloading the information so the programmer has an easy
  time doing so. The way that we use an XMLHttpRequest is by doing something like this:
  <pre>
  let cosas = new XMLHttpRequest();
  cosas.onload = cosas_a_hacer_tras_descargar;
  cosas.onerror = cosas_a_hacer_si_falla_la_descarga;
  cosas.onprogress = cosas_a_hacer_regularmente_mientras_descargo;
  cosas.onabort = cosas_a_hacer_si_hay_fallos_imprevistos;
  cosas.open("GET", "https://paginawebpreferida.com/blablabla")
  cosas.setRequestHeader("campoQueMiWebMeDiceQueTengoQuePoner", "Loquesea")
  cosas.setRequestHeader("otroCampoQueMiWebMeDiceQueTengoQuePoner", "Loquesea2")
  cosas.send()
  
  function cosas_a_hacer_tras_descargar() {
   document.getElementById("parrafo_de_information").innerHTML += "Descarga finalizada. En total fueron" + this.response.length+;
   document.getElementById("parrafo_de_contenido").innerHTML += this.response;
   let datosDeTemperatura = JSON.parse(this.response);
   document.getElementById("parrafo_de_temperatura_en_arcade").innerHTML += "La ultima temperatura en Arcade es: " + datosDeTemperatura.arcade;
   document.getElementById("parrafo_de_temperatura_en_soutomaior").innerHTML += "La ultima temperatura en Soutomaior es: " + datosDeTemperatura.soutomaior;
  }
  function cosas_a_hacer_si_falla_la_descarga() {
   document.getElementById("parrafo_de_information").innerHTML += "Descarga fallida";
  }
  function cosas_a_hacer_regularmente_mienstras_descargo() {
   document.getElementById("parrafo_de_information").innerHTML += "Descarga todavia en progreso...";
  }
  function cosas_a_hacer_si_hay_fallos_imprevistos() {
   document.getElementById("parrafo_de_information").innerHTML += "HUbo un error imprevisto...";
  }
  </pre>
  When we receive a response, the way to access its data is by means of <b>this.response</b>.
  The size of the response itself can be accessed with <b>this.response.length</b>.
  If that response is JSON, we can create a Javascript object that makes it easy to work with
  it by using <b>let datosDeArcade = JSON.parse(this.response);</b>
  
  When we connect to a website to grab information, we typically cause them a cost due to them needing
  to pay for the bandwidth to send us the information that we ask for. Thus, many websites want something
  in exchange, either money or just our information. In order to do that, a registration process is
  sometimes used, that results in we getting a piece off data called an API key or something similar, that
  we need to include in our request somehow. SOmetimes, it is in the URL that we access, like we saw
  before; some other times, the website instructs us to add it as what is called a header request, which
  is a type of data that we do not indicate in the address bar, but that gets sent by the browser. If
  the website tells us that we need to send our API key as a header request, they will need to tell us
  two things; the name of the request header, and its value. For example, if the website tells us that
  we need to include a request header named <b>apikeypassword</b> whose value is <b>blabliblu</b>, then
  we need to use the <b>setRequestHeader("apikeypassword", "blabliblu")</b> when creating the XMLHttpRequest
  object.
  
  The function send() sends the request to the destination website. Before that, we need to put all the
  needed request headers if there is any (often we do not need to put any), and say what we want to
  do when the download ends (the onload function) or fails because the website does not have the data
  we request (the onerror) or the connection is interrupted (the onabort) or, if the download takes a
  long time, what to show the user meanwhile so they are kept interested (the onprogress). If we do not
  want to do anything special, we do not need to write any of these functions other than the onload one.
  
  We can have different downloads at the same time; in this case, due to Internet congestion, and to the fact
  that sometimes websites process requests out of order, or to the fact that we are accessing different
  websites, or to different sizes of different downloads, it could be the case that although we start 
  downbloading in a given order, the downloads finish in a different order. In this case, it may be confusing
  to know which download is which. To help distinguishing them when they finish,
  we can either use a different function for each one or, to save typing, we can reuse the same function
  for all our dowloads; in this last case, we need a way to distinguish whcih of the downloads is the
  one that finished; we can add fields to the XMLHttpRequest object with whatever identifying information we want. E.g.,
  imagine that there is a website that allows us to get information about the weather in sone town by calling
  <b>https://mitiempometeorologifavorito.com/NAMEOFTOWN</b>, where we put the name of the town at the end. And it
  returns information in the following JSON format:
  <pre>
  {"humidity": "40%", "temperature": "28C", "riskOfFire": "medium to high"}
  </pre>
  
  Then, if we want to get the temperature from Arcade and Soutomaior and plot it in a paragraph whose id
  is <em>parrafo</em>, then we can use one of tow styles of Javascript code. The first is this one:
  
  <pre>
  let pueblo1 = new XMLHttpRequest();
  let pueblo2 = new XMLHttpRequest();
  pueblo1.onload = cosas_a_hacer_al_recibir_datos_de_arcade;
  pueblo2.onload = cosas_a_hacer_al_recibir_datos_de_soutomaior;
  pueblo1.open("GET", "https://mitiempometeorologifavorito.com/arcade")
  pueblo2.open("GET", "https://mitiempometeorologifavorito.com/soutomaior")
  pueblo1.send()
  pueblo2.send()
  
  function cosas_a_hacer_al_recibir_datos_de_arcade() {
   let datos = JSON.parse(this.response);
   document.getElementById("parrafo").innerHTML += "Recibida info de Arcade. La temperatura es " + datos.temperature;
  }
  function cosas_a_hacer_al_recibir_datos_de_soutomaior() {
   let datos = JSON.parse(this.response);
   document.getElementById("parrafo").innerHTML += "Recibida info de Soutomaior. La temperatura es " + datos.temperature;
  }
  </pre>
  The second is this other one, where the same function is used for both downloads, and the information
  about the town is inside a field in the XMLHttpRequest object that we chose to name <b>nombreDelSitio</b>:
  
  <pre>
  let pueblo1 = new XMLHttpRequest();
  let pueblo2 = new XMLHttpRequest();
  pueblo1.nombreDelSitio = "Arcade";
  pueblo2.nombreDelSitio = "Soutomaior";
  pueblo1.onload = cosas_a_hacer_al_recibir_datos;
  pueblo2.onload = cosas_a_hacer_al_recibir_datos;
  pueblo1.open("GET", "https://mitiempometeorologifavorito.com/arcade")
  pueblo2.open("GET", "https://mitiempometeorologifavorito.com/soutomaior")
  pueblo1.send()
  pueblo2.send()
  
  function cosas_a_hacer_al_recibir_datos() {
   let datos = JSON.parse(this.response);
   document.getElementById("parrafo").innerHTML += "Recibida info de " + this.nombreDelSitio + ". La temperatura es " + datos.temperature;
  }
  </pre>
  
  
  <h2>Example 1: weather</h2>
  Write the following two files in a new folder, run them, and tryu to understand all lines of both.
  <h2>File named ejemplo.html</h2>
  <pre>
<!doctype html>
<html>
<head>
  <title>Fun with api!</title>
  <script src="api.js" defer></script>
</head>
<body>
  <h1>The weather in some random places around the globle:</h1>
  <p id="parrafotiempo"></p>
  <h1>Error log (if any):</h1>
  <p id="parrafoerrores"></p>
  <h1>Activity log:</h1>
  <p id="parrafolog"></p>
</body>
</html>                                                                         
  </pre>
  <h2>File named api.js</h2>
  <pre>
    setTimeout(download_weather, 1000);                                             
function download_weather() {                                                   
                                                                                
 setTimeout(download_weather, 10000);                                           
                                                                                
 document.getElementById("parrafolog").innerHTML += "Sending request...<br>";   
                                                                                
 let datos_london = new XMLHttpRequest();                                       
 let datos_burgos = new XMLHttpRequest();                                       
 let datos_tokyo = new XMLHttpRequest();                                        
                                                                                
 datos_london.nombrepueblo = "London";                                          
 datos_burgos.nombrepueblo = "Burgos";                                          
 datos_tokyo.nombrepueblo = "Tokyo";                                            
                                                                                
 datos_london.onload = print_weather_in_html_webpage;                           
 datos_burgos.onload = print_weather_in_html_webpage;                           
 datos_tokyo.onload = print_weather_in_html_webpage;                            
                                                                                 
 datos_london.onerror = print_error_in_html_webpage;                            
 datos_burgos.onerror = print_error_in_html_webpage;                            
 datos_tokyo.onerror = print_error_in_html_webpage;                             
                                                                                
 datos_london.open("GET", "https://goweather.herokuapp.com/weather/London", true);
 datos_burgos.open("GET", "https://goweather.herokuapp.com/weather/Burgos", true);
 datos_tokyo.open("GET", "https://goweather.herokuapp.com/weather/Tokyo", true);
                                                                                
 datos_london.send();                                                           
 datos_burgos.send();                                                           
 datos_tokyo.send();
}                                                                               
                                                                                
function print_weather_in_html_webpage() {                                      
  // The word "this" means the XMLHttpRequest object that led to this function being calledd
  let datosjson = JSON.parse(this.response) // convertimos el json descargado a algo que Javascript entiende
  let temperatura = datosjson.temperature; // la temperatura, segun nos devuelve la web en el json
  let velocidadviento = datosjson.wind; // la fuerza de Eolo                    
  let descripcion = datosjson.description; // esto es claro, soleado, cubierto, etc
                                                                                
  // esto es para crear una cadena con la fecha y hora actuales                 
  let fechayhora = new Date().toLocaleString();                                 
                                                                                
  document.getElementById("parrafotiempo").innerHTML += "The weather in " + this.nombrepueblo;
  document.getElementById("parrafotiempo").innerHTML += " at time " + fechayhora + " is: ";
  document.getElementById("parrafotiempo").innerHTML += "temperature: " + temperatura + ", ";
  document.getElementById("parrafotiempo").innerHTML += "wind speed: " + velocidadviento + ", ";
  document.getElementById("parrafotiempo").innerHTML += "description: " + descripcion + ". Punto pelota.";
  document.getElementById("parrafotiempo").innerHTML += "<br>";                 
}                                                                               
                                                                                
function print_error_in_html_webpage() {                                        
  document.getElementById("parrafoerrores").innerHTML += "Ups, hubo un error descargando info acerca de la ciudad de: " + this.nombrepueblo + ".<br>";
}                           
  </pre>
  
  <h2>Example 2: dictionary</h2>
  For example, this one returns a definition of the word computer in english: <b>https://api.dictionaryapi.dev/api/v2/entries/en/computer</b>


</body>
</html>
